<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Jotto - 5 words, 25 characters, 1500ms | PartiallyTyped</title><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=/css/fonts.css></head><body><nav><ul class=menu><li><a href=/>Home</a></li><li><a href=/posts>All posts</a></li><li><a href=/about>About</a></li><li><a href=/tags>Tags</a></li></ul><hr></nav><div class=article-meta><h1><span class=title>Jotto - 5 words, 25 characters, 1500ms</span></h1><h2 class=date>2022/08/20</h2></div><main><h2 id=introduction>Introduction</h2><p>Wordle took the world by storm, and with it, some interesting problems reoccurred, one of which is the Jotto problem.
In short, given a collection of 5-character words, can we find 5 such that we cover 25 characters?</p><p>I was introduced to this problem by watching <a href="https://www.youtube.com/watch?v=_-AfhLQfb6w">this</a> video by Matt Parker / Standup Maths, and coincidentally, I recently had an exam on approximation algorithms, and I thought, why not. Turns out, using an approximate solution, and then rounding can give us an optimal solution faster than - as far as I can tell - any other approach. Turns out, we can further improve our speed by introducing some randomisation.</p><h2 id=abstract-away>Abstract away</h2><p>A common approach to solving optimisation problems via approximate solutions</p><ol><li>Reduce the problem in polynomial time to an integer program</li><li>Relax the integer program to a linear program</li><li>Solve the linear program</li><li>Round the solution</li></ol><h3 id=why-approximations>Why approximations?</h3><p>Simply put, speed. When the task that we are trying to solve is <a href=https://en.wikipedia.org/wiki/NP-completeness>NP-Complete</a>, we can choose one of:</p><ul><li>Fast and correct but not general. The algorithm is correct and fast for a subset of inputs (e.g. Trees instead of arbitrary graphs).</li><li>Correct and General but slow. The algorithm works for all classes of inputs, but takes exponential time at best.</li><li>General and fast, but inaccurate. The algorithm solves general problems quickly but may be inaccurate and we can only prove correctness up to a bound.</li></ul><p>In this case, we will go with the last approach.</p><h3 id=a-first-integer-program>A first integer program</h3><p>An integer program consists of an optimisation objective defined in terms of decision variables, and a set of constraints. Since we are using linear programming to build an approximate solution, we have to use a linear objective function, and linear constraints.</p><p>Our goal is to choose which words to keep such that all letters are covered. Thus, the natural integer program that comes to mind has the decision variables indicate whether the corresponding word is in the solution or not, and for each letter we have a constraint requiring the sum of the decision variables to be at least 1.</p><p>Putting it all together, we have</p><p>$$
\begin{align}
& \min\ c^T x_i \\
& \text{ subject to} \\
&\sum_{i: j \in i} x_i = 1 &\text{for all letters j} \\
& x_{i} \in \left\{0, 1\right\} & \text{for all i} \\
& c^T = \mathbb{1}
\end{align}
$$
Except that this isn&rsquo;t exactly correct, this program will construct solutions that cover all 26 letters. We will address this in a moment.</p><h3 id=a-linear-relaxation-and-a-rounding-method>A Linear relaxation and a rounding method</h3><p>Linear programs require two things, a <strong>linear</strong> objective function, and a set of <strong>linear</strong> inequalities that define the constraints.
The handwavey explanation to why we require linear objective functions and constraints relates to convexity. Simply put, each linear inequality defines a halfspace where the variables are can be satisfied, and the intersection of said halfspaces is <strong>always</strong> convex. In a convex region \(R\), any \(x,y\in R, a\in [0,1]\) satisfy \(ax + (1-a)y \in R \).</p><p>Linear programs are not as restrictive as integer programs when it comes to the decision variables as they allow for real values instead of integer ones.
Notice however that since linear programs can take integer solutions any solution to the integer program is a feasible solution,
that is, it is an acceptable solution to the linear program. This means that in the case of minimization,
the linear program can achieve solutions at least as good as those of the integer program; thus $$LP^\star \leq ZP^\star$$
where \(LP^\star\) is the value of the optimal solution to the linear program and \(ZP^\star\) is the value of the optimal solution to the integer program.</p><p>In general, we define linear programs to take positive values only, and we provide an upper bound on them. By restricting the values from above, we ensure that regardless of the coefficients in the objective function,</p><h4 id=variable-constraints>Variable constraints</h4><p>The minimization objective remains the same, we just need to ensure that the constraints are. First, we will turn the integer variables to &ldquo;real&rdquo; variables by requiring that
$$ x_{i} \geq 0 \text{ for all i}$$ Notice we are minimizing over a sum of positive numbers with positive coefficients, this means that unless there is advantage in getting values higher than 1, we do not need to provide an upper bound. If we wanted to provide one, we would do $$x_{i} \leq 1 \text{ for all i}$$.</p><h4 id=character-constraints>Character constraints</h4><p>Similarly to above, $$\sum_{i: j \in i} x_i = 1 \text{ for all letters j}$$, however, we do not need to use equality. Again, since this is a minimization objective, we can simply ask to have a value above or equal to 1. Since there is no advantage to having higher values, but instead there is a penalty, the LP will try to avoid higher values in the respective decision variables.</p><h4 id=rounding>Rounding</h4><p>We now require a rounding mechanism to go from the linear solution to the integer one. Given the decision variables \(x\), we select the variables that have a value \(x_{i} \geq f\), where \[f = (max_{l} |\{w| l\in w, \text{ w is a word} \}|)^{-1} \] where \(l\) is a letter of the alphabet. In essence, we round up the decision variables which have a value higher than the reciprocal of the maximum number of ways a given letter can be covered. This is guaranteed to give us a feasible but not necessarily optimal solution to the set cover problem. Can you prove why?</p><h4 id=a-problem-with-convexity>A problem with convexity</h4><p>Because the intersection of halfspaces is convex, there can be eaxctly 0, 1 or infinite solutions. Zero solutions occur when the intersection of the halfspaces is empty.
If the intersection of the halfspaces is non empty, then it is a polyhedron. Due to the linear nature of the objective function, we can identify a direction which it increases or decreases. If we follow this direction and obey the constrainst, we will either terminate on a vertex, or on a plane. If we terminate on a vertex, then there exists a single solution, otherwise, there exist an infinite number. This can cause issues when it comes to rounding, so we will intead ask the solver to provide integer solutions.</p><h2 id=back-to-jotto>Back to Jotto</h2><p>Notice that what we solved above is merely another instance of the set-cover problem, where the set we had to cover was the set of all letters in the alphabet. The jotto problem however does not ask for that, it simply asks to cover any combination of 25 letters. When we reduce a task to a decision problem, the decision problem simply tells us whether a solution given the parameters exists, thus if we would like to decide the minimum number to solve a task, we start from 0 and go up to find the minimum value where the decision problem returns True.</p><p>We will take a note from this approach and instead of trying to solve the full Jotto problem with LP, we will solve 26 set-cover problems, and stop as soon as we find a satisfying solution. For each letter, we will attempt to cover the remaining 25 letters using only words that don&rsquo;t have it.</p><h2 id=other-tricks>Other tricks</h2><h3 id=randomizing-the-runtime>Randomizing the runtime</h3><p>Assuming that we do not know <em>which</em> letter we need to exclude, going over 26 characters means if the letter that will yield a solution is towards the end, we end up wasting precious time. We can take a hint from randomized algorithms and construct a solution that is faster on average / in the expectation simply by shuffling the order with which we go through the letters. If the target letter is after the middle, then on average we have a faster solution (hint, it is).</p><h3 id=permutation-invariant-hashing>Permutation invariant hashing</h3><p>Assume for a moment that we have the words &ldquo;abc&rdquo;, and &ldquo;bca&rdquo;, the two words are simply a permutation of each other, thus we can get away with removing either of them without risking breaking the solution since the two words are equivalent. We can perform this grouping by using a permutation invariant hashing.</p><p>The simplest one in python is \( hash \circ tuple \circ sorted \), ie sort the letters, create a tuple and hash it.</p><p>Alternatively, one can create a hash value using the shift operator</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>invariant_shift</span>(string):
</span></span><span style=display:flex><span>    h <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> c <span style=color:#f92672>in</span> string:
</span></span><span style=display:flex><span>        h <span style=color:#f92672>|=</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> ord(c)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> h
</span></span></code></pre></div><p>However this creates collisions with words like &ldquo;aaabb&rdquo; and &ldquo;bbbaa&rdquo; but it probably doesn&rsquo;t matter.</p><h2 id=putting-it-all-together>Putting it all together</h2><p>We define a parametrized linear program \(LP(l)\):</p><p>$$
\begin{align}
& min \sum_{i} x_i \\
& \text{ subject to} \\
&\sum_{i: j \in i} x_i \geq 1 &\text{for all letters j} \neq l \\
& x_{i} \geq 0 & \text{for each word i, where } l \not \in i
\end{align}
$$</p><h3 id=imports-and-basic-filtering>Imports and basic filtering</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>from</span> itertools <span style=color:#f92672>import</span> groupby
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> toolz <span style=color:#f92672>import</span> compose
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> numpy <span style=color:#66d9ef>as</span> np
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> scipy.optimize <span style=color:#f92672>import</span> linprog
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> random <span style=color:#f92672>import</span> shuffle
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>perm_invariant_hash <span style=color:#f92672>=</span> compose(hash, tuple, sorted)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>words <span style=color:#f92672>=</span> open(<span style=color:#e6db74>&#34;/Users/quinn/Desktop/words_alpha.txt&#34;</span>)<span style=color:#f92672>.</span>readlines()
</span></span><span style=display:flex><span>words <span style=color:#f92672>=</span> (word<span style=color:#f92672>.</span>strip()<span style=color:#f92672>.</span>lower() <span style=color:#66d9ef>for</span> word <span style=color:#f92672>in</span> words)
</span></span><span style=display:flex><span>words <span style=color:#f92672>=</span> (word <span style=color:#66d9ef>for</span> word <span style=color:#f92672>in</span> words <span style=color:#66d9ef>if</span> len(word) <span style=color:#f92672>==</span> <span style=color:#ae81ff>5</span>)
</span></span><span style=display:flex><span>words <span style=color:#f92672>=</span> (w <span style=color:#66d9ef>for</span> w <span style=color:#f92672>in</span> words <span style=color:#66d9ef>if</span> len(set(w)) <span style=color:#f92672>==</span> <span style=color:#ae81ff>5</span>)
</span></span><span style=display:flex><span>words <span style=color:#f92672>=</span> groupby(words, key<span style=color:#f92672>=</span>perm_invariant_hash)
</span></span><span style=display:flex><span>words <span style=color:#f92672>=</span> [next(w) <span style=color:#66d9ef>for</span> i, (_, w) <span style=color:#f92672>in</span> enumerate(words)]
</span></span></code></pre></div><h3 id=main-loop>Main Loop</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>letters <span style=color:#f92672>=</span> list(<span style=color:#e6db74>&#34;abcdefghijklnopqrstuvwxyzm&#34;</span>)
</span></span><span style=display:flex><span>shuffle(letters)
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> letter <span style=color:#f92672>in</span> letters:
</span></span><span style=display:flex><span>    sol, rounded_solution <span style=color:#f92672>=</span> solve(letter, words)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> sol <span style=color:#f92672>is</span> <span style=color:#66d9ef>None</span>:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>continue</span>
</span></span><span style=display:flex><span>    val <span style=color:#f92672>=</span> sum(sol<span style=color:#f92672>.</span>x)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> len(rounded_solution) <span style=color:#f92672>==</span> <span style=color:#ae81ff>5</span>:
</span></span><span style=display:flex><span>        print(letter, rounded_solution)
</span></span><span style=display:flex><span>        exit(<span style=color:#ae81ff>0</span>)
</span></span></code></pre></div><h3 id=lp>LP</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>solve</span>(letter, words:dict):
</span></span><span style=display:flex><span>    words <span style=color:#f92672>=</span> [w <span style=color:#66d9ef>for</span> w <span style=color:#f92672>in</span> words <span style=color:#66d9ef>if</span> letter <span style=color:#f92672>not</span> <span style=color:#f92672>in</span> w]
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e># since we are removing a letter, using ord(c) breaks</span>
</span></span><span style=display:flex><span>    letter_to_index <span style=color:#f92672>=</span> enumerate(l <span style=color:#66d9ef>for</span> l <span style=color:#f92672>in</span> <span style=color:#e6db74>&#34;abcdefghijklmnopqrstuvwxyz&#34;</span> <span style=color:#66d9ef>if</span> l <span style=color:#f92672>!=</span> letter)
</span></span><span style=display:flex><span>    letter_to_index <span style=color:#f92672>=</span> {l: i <span style=color:#66d9ef>for</span> i, l <span style=color:#f92672>in</span> letter_to_index}
</span></span><span style=display:flex><span>    n <span style=color:#f92672>=</span> len(words)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># these are the coefficients to the linear program</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># since we are not doing weighted sum, using a vector of 1s gives us a simple summation    </span>
</span></span><span style=display:flex><span>    coefs <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>ones(n)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># scipy&#39;s linprog needs upper bounds for the constraints, since the xs are positive,</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># we use negative coefficients with negative target values</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># for each letter, we create a row, where the ith column has -1 coefficient when </span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># the corresponding letter is in the word</span>
</span></span><span style=display:flex><span>    A_ub <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>zeros((<span style=color:#ae81ff>25</span>, n))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i, word <span style=color:#f92672>in</span> enumerate(words):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> l <span style=color:#f92672>in</span> word:
</span></span><span style=display:flex><span>            A_ub[letter_to_index[l], i] <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    b_ub <span style=color:#f92672>=</span> <span style=color:#f92672>-</span>np<span style=color:#f92672>.</span>ones(<span style=color:#ae81ff>25</span>)
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># we can make use of integrality parameter and ask the LP</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># give a solution where all variables are integers.</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># this makes the solution more costly, but avoids the</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># rounding errors due to infinite solutions.</span>
</span></span><span style=display:flex><span>    res <span style=color:#f92672>=</span> linprog(coefs, A_ub<span style=color:#f92672>=</span>A_ub, b_ub<span style=color:#f92672>=</span>b_ub, integrality<span style=color:#f92672>=</span><span style=color:#ae81ff>2</span><span style=color:#f92672>*</span>np<span style=color:#f92672>.</span>ones(n))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> res<span style=color:#f92672>.</span>status <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span>:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>None</span>, <span style=color:#66d9ef>None</span>    
</span></span><span style=display:flex><span>    rounded_solution <span style=color:#f92672>=</span> [words[i] <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(len(words)) <span style=color:#66d9ef>if</span> res<span style=color:#f92672>.</span>x[i]]
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> res, rounded_solution
</span></span></code></pre></div><h2 id=results>Results</h2><p>This takes 0.7s and 1.7s when m is evaluated first and last respectively on my baseline m1 macbook air.
The main cost is solving the LP/IP, thus optimizations that don&rsquo;t reduce the decision variables will barely affect the runtime.</p></main><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script type=text/javascript id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js></script>